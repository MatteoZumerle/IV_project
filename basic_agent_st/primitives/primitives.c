/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * primitives.c
 *
 * Code generation for function 'primitives'
 *
 */

/* Include files */
#include "primitives.h"
#include "rt_nonfinite.h"
#include "rt_nonfinite.h"
#include <math.h>

/* Variable Definitions */
static boolean_T isInitialized_primitives = false;

/* Function Declarations */
static double rt_powd_snf(double u0, double u1);

/* Function Definitions */
static double rt_powd_snf(double u0, double u1)
{
  double d;
  double d1;
  double y;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = rtNaN;
  } else {
    d = fabs(u0);
    d1 = fabs(u1);
    if (rtIsInf(u1)) {
      if (d == 1.0) {
        y = 1.0;
      } else if (d > 1.0) {
        if (u1 > 0.0) {
          y = rtInf;
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = rtInf;
      }
    } else if (d1 == 0.0) {
      y = 1.0;
    } else if (d1 == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > floor(u1))) {
      y = rtNaN;
    } else {
      y = pow(u0, u1);
    }
  }
  return y;
}

void PassingPrimitive(double a0, double v0, double sf, double b_vmin,
                      double b_vmax, double Tmin, double Tmax, double m1[5],
                      double m2[5])
{
  double Tstar;
  double Vstar;
  double b_vf_tmp;
  double c_vf_tmp;
  double intersection_min;
  double t3;
  double t4;
  double vf_tmp;
  int i;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* Check the value of initial velocity to avoid stationary behavior */
  if (a0 >= 0.0) {
    /* finalOptTimePass */
    /*     OUT1 = finalOptTimePass(V0,A0,SF,VF) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     03-Nov-2023 09:51:11 */
    Vstar = a0 * sf * 60.0;
    intersection_min = v0 * v0 * 49.0;
    Tstar = sf * 30.0 /
            ((v0 * 7.0 + b_vmin * 8.0) +
             sqrt(((Vstar + v0 * b_vmin * 112.0) + intersection_min) +
                  b_vmin * b_vmin * 64.0));
    /* finalOptTimePass */
    /*     OUT1 = finalOptTimePass(V0,A0,SF,VF) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     03-Nov-2023 09:51:11 */
    Vstar = sf * 30.0 /
            ((v0 * 7.0 + b_vmax * 8.0) +
             sqrt(((Vstar + v0 * b_vmax * 112.0) + intersection_min) +
                  b_vmax * b_vmax * 64.0));
  } else {
    /* timeMinVelPass */
    /*     OUT1 = timeMinVelPass(A0,SF) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     03-Nov-2023 09:51:11 */
    Tstar = -(3.872983346207417 * sqrt(-a0 * sf)) / a0;
    /* finalOptVelPass */
    /*     FINAL_OPT_VELOCITY_TIME_PASS_VAR = finalOptVelPass(V0,A0,SF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     03-Nov-2023 09:51:11 */
    Vstar =
        ((sf * -15.0 + Tstar * v0 * 7.0) + Tstar * Tstar * a0) * -0.125 / Tstar;
    if ((b_vmin >= Vstar) && (b_vmin <= b_vmax)) {
      /* finalOptTimePass */
      /*     OUT1 = finalOptTimePass(V0,A0,SF,VF) */
      /*     This function was generated by the Symbolic Math Toolbox
       * version 23.2. */
      /*     03-Nov-2023 09:51:11 */
      Vstar = a0 * sf * 60.0;
      intersection_min = v0 * v0 * 49.0;
      Tstar = sf * 30.0 /
              ((v0 * 7.0 + b_vmin * 8.0) +
               sqrt(((Vstar + v0 * b_vmin * 112.0) + intersection_min) +
                    b_vmin * b_vmin * 64.0));
      /* finalOptTimePass */
      /*     OUT1 = finalOptTimePass(V0,A0,SF,VF) */
      /*     This function was generated by the Symbolic Math Toolbox
       * version 23.2. */
      /*     03-Nov-2023 09:51:11 */
      Vstar = sf * 30.0 /
              ((v0 * 7.0 + b_vmax * 8.0) +
               sqrt(((Vstar + v0 * b_vmax * 112.0) + intersection_min) +
                    b_vmax * b_vmax * 64.0));
    } else if ((b_vmin <= Vstar) && (Vstar <= b_vmax)) {
      /* finalOptTimePass */
      /*     OUT1 = finalOptTimePass(V0,A0,SF,VF) */
      /*     This function was generated by the Symbolic Math Toolbox
       * version 23.2. */
      /*     03-Nov-2023 09:51:11 */
      Vstar = sf * 30.0 /
              ((v0 * 7.0 + b_vmax * 8.0) +
               sqrt(((a0 * sf * 60.0 + v0 * b_vmax * 112.0) + v0 * v0 * 49.0) +
                    b_vmax * b_vmax * 64.0));
    } else {
      Tstar = 0.0;
      Vstar = 0.0;
    }
  }
  if ((Tmin >= Vstar) || rtIsNaN(Vstar)) {
    intersection_min = Tmin;
  } else {
    intersection_min = Vstar;
  }
  if ((Tmax <= Tstar) || rtIsNaN(Tstar)) {
    Tstar = Tmax;
  }
  /*  Verifica se c'Ã¨ un'intersezione valida */
  if (!(intersection_min <= Tstar)) {
    intersection_min = 0.0;
    Tstar = 0.0;
  }
  if ((intersection_min > 0.0) && (intersection_min <= Tstar)) {
    /* finalOptVelPass */
    /*     FINAL_OPT_VELOCITY_TIME_PASS_VAR = finalOptVelPass(V0,A0,SF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     03-Nov-2023 09:51:11 */
    /* finalOptVelPass */
    /*     FINAL_OPT_VELOCITY_TIME_PASS_VAR = finalOptVelPass(V0,A0,SF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     03-Nov-2023 09:51:11 */
    vf_tmp = intersection_min * intersection_min;
    b_vf_tmp = vf_tmp * a0;
    c_vf_tmp = intersection_min * v0;
    /* evalPrimitiveCoeffs */
    /*     COEFFICENT_V = evalPrimitiveCoeffs(V0,A0,SF,VF,AF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     03-Nov-2023 09:51:10 */
    t3 = 0.0 * vf_tmp;
    t4 = b_vf_tmp * 3.0;
    m1[0] = v0;
    m1[1] = a0;
    Vstar = intersection_min * (((sf * -15.0 + c_vf_tmp * 7.0) + b_vf_tmp) *
                                -0.125 / intersection_min);
    m1[2] = 1.0 / rt_powd_snf(intersection_min, 3.0) *
            ((((sf * -20.0 + t4) - t3) + c_vf_tmp * 12.0) + Vstar * 8.0) * -3.0;
    m1[3] =
        1.0 / (vf_tmp * vf_tmp) *
        ((((sf * -30.0 - t3 * 2.0) + t4) + c_vf_tmp * 16.0) + Vstar * 14.0) *
        12.0;
    m1[4] = 1.0 / rt_powd_snf(intersection_min, 5.0) *
            ((((sf * -12.0 - t3) + c_vf_tmp * 6.0) + Vstar * 6.0) + b_vf_tmp) *
            -60.0;
    vf_tmp = Tstar * Tstar;
    b_vf_tmp = vf_tmp * a0;
    c_vf_tmp = Tstar * v0;
    /* evalPrimitiveCoeffs */
    /*     COEFFICENT_V = evalPrimitiveCoeffs(V0,A0,SF,VF,AF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     03-Nov-2023 09:51:10 */
    t3 = 0.0 * vf_tmp;
    t4 = b_vf_tmp * 3.0;
    m2[0] = v0;
    m2[1] = a0;
    Vstar =
        Tstar * (((sf * -15.0 + c_vf_tmp * 7.0) + b_vf_tmp) * -0.125 / Tstar);
    m2[2] = 1.0 / rt_powd_snf(Tstar, 3.0) *
            ((((sf * -20.0 + t4) - t3) + c_vf_tmp * 12.0) + Vstar * 8.0) * -3.0;
    m2[3] =
        1.0 / (vf_tmp * vf_tmp) *
        ((((sf * -30.0 - t3 * 2.0) + t4) + c_vf_tmp * 16.0) + Vstar * 14.0) *
        12.0;
    m2[4] = 1.0 / rt_powd_snf(Tstar, 5.0) *
            ((((sf * -12.0 - t3) + c_vf_tmp * 6.0) + Vstar * 6.0) + b_vf_tmp) *
            -60.0;
  } else {
    for (i = 0; i < 5; i++) {
      m1[i] = 0.0;
      m2[i] = 0.0;
    }
  }
}

void StoppingPrimitive(double a0, double v0, double sf, double coeffs[5],
                       double *s_max, double *tf)
{
  double coeffs_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  int i;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* Check the value of initial velocity to avoid stationary behavior */
  if ((v0 <= 0.0) || (sf <= 0.0)) {
    for (i = 0; i < 5; i++) {
      coeffs[i] = 0.0;
    }
    *tf = 0.0;
    *s_max = 0.0;
  } else {
    t2 = 4.0 * (v0 * v0);
    if (t2 + 5.0 * a0 * sf < 0.0) {
      *s_max = -t2 / (5.0 * a0);
      *tf = 10.0 * *s_max / (2.0 * v0);
    } else {
      *s_max = sf;
      /* finalOptTimeStop */
      /*     OUT1 = finalOptTimeStop(V0,A0,SF) */
      /*     This function was generated by the Symbolic Math Toolbox
       * version 23.2. */
      /*     03-Nov-2023 09:51:10 */
      *tf = sf * 10.0 / (v0 * 2.0 + sqrt(a0 * sf * 5.0 + t2));
    }
    /* evalPrimitiveCoeffs */
    /*     COEFFICENT_V = evalPrimitiveCoeffs(V0,A0,SF,VF,AF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     03-Nov-2023 09:51:10 */
    t2 = *tf * *tf;
    t3 = 0.0 * t2;
    t4_tmp = a0 * t2;
    t4 = t4_tmp * 3.0;
    coeffs[0] = v0;
    coeffs[1] = a0;
    coeffs_tmp = *tf * v0;
    coeffs[2] =
        1.0 / rt_powd_snf(*tf, 3.0) *
        ((((*s_max * -20.0 + t4) - t3) + coeffs_tmp * 12.0) + *tf * 0.0 * 8.0) *
        -3.0;
    coeffs[3] = 1.0 / (t2 * t2) *
                ((((*s_max * -30.0 - t3 * 2.0) + t4) + coeffs_tmp * 16.0) +
                 *tf * 0.0 * 14.0) *
                12.0;
    coeffs[4] =
        1.0 / rt_powd_snf(*tf, 5.0) *
        ((((*s_max * -12.0 - t3) + coeffs_tmp * 6.0) + *tf * 0.0 * 6.0) +
         t4_tmp) *
        -60.0;
  }
}

void primitives_initialize(void)
{
  rt_InitInfAndNaN();
  isInitialized_primitives = true;
}

void primitives_terminate(void)
{
  isInitialized_primitives = false;
}

/* End of code generation (primitives.c) */
