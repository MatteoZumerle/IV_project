/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * primitives.c
 *
 * Code generation for function 'primitives'
 *
 */

/* Include files */
#include "primitives.h"
#include "rt_nonfinite.h"
#include "rt_nonfinite.h"
#include <math.h>

/* Variable Definitions */
static boolean_T isInitialized_primitives = false;

/* Function Declarations */
static double rt_powd_snf(double u0, double u1);

/* Function Definitions */
static double rt_powd_snf(double u0, double u1)
{
  double d;
  double d1;
  double y;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = rtNaN;
  } else {
    d = fabs(u0);
    d1 = fabs(u1);
    if (rtIsInf(u1)) {
      if (d == 1.0) {
        y = 1.0;
      } else if (d > 1.0) {
        if (u1 > 0.0) {
          y = rtInf;
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = rtInf;
      }
    } else if (d1 == 0.0) {
      y = 1.0;
    } else if (d1 == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > floor(u1))) {
      y = rtNaN;
    } else {
      y = pow(u0, u1);
    }
  }
  return y;
}

void PassingPrimitive(double a0, double v0, double sf, double b_vmin,
                      double b_vmax, double Tmin, double Tmax, double m1[6],
                      double m2[6])
{
  double Tstar;
  double Vstar;
  double b_vf_tmp;
  double c_vf_tmp;
  double intersection_min;
  double t3;
  double t4;
  double vf_tmp;
  int i;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* Check the value of initial velocity to avoid stationary behavior */
  if (a0 >= 0.0) {
    /* finalOptTimePass */
    /*     OUT1 = finalOptTimePass(V0,A0,SF,VF) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     21-Nov-2023 12:11:12 */
    Vstar = a0 * sf * 60.0;
    intersection_min = v0 * v0 * 49.0;
    Tstar = sf * 30.0 /
            ((v0 * 7.0 + b_vmin * 8.0) +
             sqrt(((Vstar + v0 * b_vmin * 112.0) + intersection_min) +
                  b_vmin * b_vmin * 64.0));
    /* finalOptTimePass */
    /*     OUT1 = finalOptTimePass(V0,A0,SF,VF) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     21-Nov-2023 12:11:12 */
    Vstar = sf * 30.0 /
            ((v0 * 7.0 + b_vmax * 8.0) +
             sqrt(((Vstar + v0 * b_vmax * 112.0) + intersection_min) +
                  b_vmax * b_vmax * 64.0));
  } else {
    /* timeMinVelPass */
    /*     OUT1 = timeMinVelPass(A0,SF) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     21-Nov-2023 12:11:12 */
    Tstar = -(3.872983346207417 * sqrt(-a0 * sf)) / a0;
    /* finalOptVelPass */
    /*     FINAL_OPT_VELOCITY_TIME_PASS_VAR = finalOptVelPass(V0,A0,SF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     21-Nov-2023 12:11:12 */
    Vstar =
        ((sf * -15.0 + Tstar * v0 * 7.0) + Tstar * Tstar * a0) * -0.125 / Tstar;
    if ((b_vmin >= Vstar) && (b_vmin <= b_vmax)) {
      /* finalOptTimePass */
      /*     OUT1 = finalOptTimePass(V0,A0,SF,VF) */
      /*     This function was generated by the Symbolic Math Toolbox
       * version 23.2. */
      /*     21-Nov-2023 12:11:12 */
      Vstar = a0 * sf * 60.0;
      intersection_min = v0 * v0 * 49.0;
      Tstar = sf * 30.0 /
              ((v0 * 7.0 + b_vmin * 8.0) +
               sqrt(((Vstar + v0 * b_vmin * 112.0) + intersection_min) +
                    b_vmin * b_vmin * 64.0));
      /* finalOptTimePass */
      /*     OUT1 = finalOptTimePass(V0,A0,SF,VF) */
      /*     This function was generated by the Symbolic Math Toolbox
       * version 23.2. */
      /*     21-Nov-2023 12:11:12 */
      Vstar = sf * 30.0 /
              ((v0 * 7.0 + b_vmax * 8.0) +
               sqrt(((Vstar + v0 * b_vmax * 112.0) + intersection_min) +
                    b_vmax * b_vmax * 64.0));
    } else if ((b_vmin <= Vstar) && (Vstar <= b_vmax)) {
      /* finalOptTimePass */
      /*     OUT1 = finalOptTimePass(V0,A0,SF,VF) */
      /*     This function was generated by the Symbolic Math Toolbox
       * version 23.2. */
      /*     21-Nov-2023 12:11:12 */
      Vstar = sf * 30.0 /
              ((v0 * 7.0 + b_vmax * 8.0) +
               sqrt(((a0 * sf * 60.0 + v0 * b_vmax * 112.0) + v0 * v0 * 49.0) +
                    b_vmax * b_vmax * 64.0));
    } else {
      Tstar = 0.0;
      Vstar = 0.0;
    }
  }
  if ((Tmin >= Vstar) || rtIsNaN(Vstar)) {
    intersection_min = Tmin;
  } else {
    intersection_min = Vstar;
  }
  if ((Tmax <= Tstar) || rtIsNaN(Tstar)) {
    Tstar = Tmax;
  }
  /*  Verifica se c'Ã¨ un'intersezione valida */
  if (!(intersection_min <= Tstar)) {
    intersection_min = 0.0;
    Tstar = 0.0;
  }
  if ((intersection_min > 0.0) && (intersection_min <= Tstar)) {
    /* finalOptVelPass */
    /*     FINAL_OPT_VELOCITY_TIME_PASS_VAR = finalOptVelPass(V0,A0,SF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     21-Nov-2023 12:11:12 */
    /* finalOptVelPass */
    /*     FINAL_OPT_VELOCITY_TIME_PASS_VAR = finalOptVelPass(V0,A0,SF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     21-Nov-2023 12:11:12 */
    vf_tmp = intersection_min * intersection_min;
    b_vf_tmp = vf_tmp * a0;
    c_vf_tmp = intersection_min * v0;
    /* evalPrimitiveCoeffs */
    /*     COEFFICENT_V = evalPrimitiveCoeffs(V0,A0,SF,VF,AF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     21-Nov-2023 12:11:11 */
    t3 = 0.0 * vf_tmp;
    t4 = b_vf_tmp * 3.0;
    m1[0] = 0.0;
    m1[1] = v0;
    m1[2] = a0;
    Vstar = intersection_min * (((sf * -15.0 + c_vf_tmp * 7.0) + b_vf_tmp) *
                                -0.125 / intersection_min);
    m1[3] = 1.0 / rt_powd_snf(intersection_min, 3.0) *
            ((((sf * -20.0 + t4) - t3) + c_vf_tmp * 12.0) + Vstar * 8.0) * -3.0;
    m1[4] =
        1.0 / (vf_tmp * vf_tmp) *
        ((((sf * -30.0 - t3 * 2.0) + t4) + c_vf_tmp * 16.0) + Vstar * 14.0) *
        12.0;
    m1[5] = 1.0 / rt_powd_snf(intersection_min, 5.0) *
            ((((sf * -12.0 - t3) + c_vf_tmp * 6.0) + Vstar * 6.0) + b_vf_tmp) *
            -60.0;
    vf_tmp = Tstar * Tstar;
    b_vf_tmp = vf_tmp * a0;
    c_vf_tmp = Tstar * v0;
    /* evalPrimitiveCoeffs */
    /*     COEFFICENT_V = evalPrimitiveCoeffs(V0,A0,SF,VF,AF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     21-Nov-2023 12:11:11 */
    t3 = 0.0 * vf_tmp;
    t4 = b_vf_tmp * 3.0;
    m2[0] = 0.0;
    m2[1] = v0;
    m2[2] = a0;
    Vstar =
        Tstar * (((sf * -15.0 + c_vf_tmp * 7.0) + b_vf_tmp) * -0.125 / Tstar);
    m2[3] = 1.0 / rt_powd_snf(Tstar, 3.0) *
            ((((sf * -20.0 + t4) - t3) + c_vf_tmp * 12.0) + Vstar * 8.0) * -3.0;
    m2[4] =
        1.0 / (vf_tmp * vf_tmp) *
        ((((sf * -30.0 - t3 * 2.0) + t4) + c_vf_tmp * 16.0) + Vstar * 14.0) *
        12.0;
    m2[5] = 1.0 / rt_powd_snf(Tstar, 5.0) *
            ((((sf * -12.0 - t3) + c_vf_tmp * 6.0) + Vstar * 6.0) + b_vf_tmp) *
            -60.0;
  } else {
    for (i = 0; i < 6; i++) {
      m1[i] = 0.0;
      m2[i] = 0.0;
    }
  }
}

void PassingPrimitivej0(double a0, double v0, double sf, double b_vmin,
                        double b_vmax, double m1[6])
{
  double T_idx_0;
  double T_idx_1;
  double b_v1_tmp;
  double t10;
  double t2;
  double t3;
  double t4;
  double v1_tmp;
  double v1_tmp_tmp;
  int i;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* pag 76/104 seems that also sf is requied */
  /* finalOptTimePassj0 */
  /*     T_vf_j0 = finalOptTimePassj0(V0,A0,SF) */
  /*     This function was generated by the Symbolic Math Toolbox version 23.2.
   */
  /*     21-Nov-2023 12:11:12 */
  t2 = v0 * 5.0;
  t4 = 1.0 / a0;
  t10 = 2.23606797749979 * sqrt(a0 * sf * 8.0 + t2 * v0);
  T_idx_0 = t4 * (t2 + t10) * -0.25;
  T_idx_1 = t4 * (t2 - t10) * -0.25;
  /* finalOptVelj0 */
  /*     VF_J0 = finalOptVelj0(V0,A0,SF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 23.2.
   */
  /*     21-Nov-2023 12:11:12 */
  t4 = T_idx_0 * T_idx_0;
  t10 = t4 * a0;
  v1_tmp = t10 * 3.0;
  v1_tmp_tmp = T_idx_0 * v0;
  b_v1_tmp = v1_tmp_tmp * 12.0;
  t2 = ((sf * -20.0 + b_v1_tmp) + v1_tmp) * -0.125 / T_idx_0;
  if ((b_vmin < t2) && (t2 < b_vmax)) {
    /* evalPrimitiveCoeffs */
    /*     COEFFICENT_V = evalPrimitiveCoeffs(V0,A0,SF,VF,AF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     21-Nov-2023 12:11:11 */
    t3 = 0.0 * t4;
    m1[0] = 0.0;
    m1[1] = v0;
    m1[2] = a0;
    t2 *= T_idx_0;
    m1[3] = 1.0 / rt_powd_snf(T_idx_0, 3.0) *
            ((((sf * -20.0 + v1_tmp) - t3) + b_v1_tmp) + t2 * 8.0) * -3.0;
    m1[4] =
        1.0 / (t4 * t4) *
        ((((sf * -30.0 - t3 * 2.0) + v1_tmp) + v1_tmp_tmp * 16.0) + t2 * 14.0) *
        12.0;
    m1[5] = 1.0 / rt_powd_snf(T_idx_0, 5.0) *
            ((((sf * -12.0 - t3) + v1_tmp_tmp * 6.0) + t2 * 6.0) + t10) * -60.0;
  } else {
    /* finalOptVelj0 */
    /*     VF_J0 = finalOptVelj0(V0,A0,SF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     21-Nov-2023 12:11:12 */
    t4 = T_idx_1 * T_idx_1;
    t10 = t4 * a0;
    v1_tmp = t10 * 3.0;
    v1_tmp_tmp = T_idx_1 * v0;
    b_v1_tmp = v1_tmp_tmp * 12.0;
    t2 = ((sf * -20.0 + b_v1_tmp) + v1_tmp) * -0.125 / T_idx_1;
    if ((b_vmin < t2) && (t2 < b_vmax)) {
      /* evalPrimitiveCoeffs */
      /*     COEFFICENT_V = evalPrimitiveCoeffs(V0,A0,SF,VF,AF,T) */
      /*     This function was generated by the Symbolic Math Toolbox
       * version 23.2. */
      /*     21-Nov-2023 12:11:11 */
      t3 = 0.0 * t4;
      m1[0] = 0.0;
      m1[1] = v0;
      m1[2] = a0;
      t2 *= T_idx_1;
      m1[3] = 1.0 / rt_powd_snf(T_idx_1, 3.0) *
              ((((sf * -20.0 + v1_tmp) - t3) + b_v1_tmp) + t2 * 8.0) * -3.0;
      m1[4] = 1.0 / (t4 * t4) *
              ((((sf * -30.0 - t3 * 2.0) + v1_tmp) + v1_tmp_tmp * 16.0) +
               t2 * 14.0) *
              12.0;
      m1[5] = 1.0 / rt_powd_snf(T_idx_1, 5.0) *
              ((((sf * -12.0 - t3) + v1_tmp_tmp * 6.0) + t2 * 6.0) + t10) *
              -60.0;
    } else {
      for (i = 0; i < 6; i++) {
        m1[i] = 0.0;
      }
    }
  }
}

void StoppingPrimitive(double v0, double a0, double sf, double coeffs[6],
                       double *s_max, double *tf)
{
  double coeffs_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  int i;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* Check the value of initial velocity to avoid stationary behavior */
  if ((v0 <= 0.0) || (sf <= 0.0)) {
    for (i = 0; i < 6; i++) {
      coeffs[i] = 0.0;
    }
    *tf = 0.0;
    *s_max = 0.0;
  } else {
    *s_max = sf;
    t2 = 4.0 * (v0 * v0);
    if (t2 + 5.0 * a0 * sf < 0.0) {
      *s_max = -t2 / (5.0 * a0);
      *tf = 10.0 * *s_max / (2.0 * v0);
    } else {
      /* finalOptTimeStop */
      /*     OUT1 = finalOptTimeStop(V0,A0,SF) */
      /*     This function was generated by the Symbolic Math Toolbox
       * version 23.2. */
      /*     21-Nov-2023 12:11:11 */
      *tf = sf * 10.0 / (v0 * 2.0 + sqrt(a0 * sf * 5.0 + t2));
    }
    /* evalPrimitiveCoeffs */
    /*     COEFFICENT_V = evalPrimitiveCoeffs(V0,A0,SF,VF,AF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     21-Nov-2023 12:11:11 */
    t2 = *tf * *tf;
    t3 = 0.0 * t2;
    t4_tmp = a0 * t2;
    t4 = t4_tmp * 3.0;
    coeffs[0] = 0.0;
    coeffs[1] = v0;
    coeffs[2] = a0;
    coeffs_tmp = *tf * v0;
    coeffs[3] =
        1.0 / rt_powd_snf(*tf, 3.0) *
        ((((*s_max * -20.0 + t4) - t3) + coeffs_tmp * 12.0) + *tf * 0.0 * 8.0) *
        -3.0;
    coeffs[4] = 1.0 / (t2 * t2) *
                ((((*s_max * -30.0 - t3 * 2.0) + t4) + coeffs_tmp * 16.0) +
                 *tf * 0.0 * 14.0) *
                12.0;
    coeffs[5] =
        1.0 / rt_powd_snf(*tf, 5.0) *
        ((((*s_max * -12.0 - t3) + coeffs_tmp * 6.0) + *tf * 0.0 * 6.0) +
         t4_tmp) *
        -60.0;
  }
}

void StoppingPrimitivej0(double a0, double v0, double m[6], double *s_max,
                         double *tf)
{
  double b_s_max_tmp;
  double c_s_max_tmp;
  double s_max_tmp;
  double t3;
  double t4;
  int i;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* pag 76/104 seems that also sf is requied */
  if ((v0 > 0.0) && (a0 < 0.0)) {
    /* finalOptTimeStopj0 */
    /*     OUT1 = finalOptTimeStopj0(V0,A0) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     21-Nov-2023 12:11:12 */
    *tf = v0 * -2.0 / a0;
    /* finalOptPosj0 */
    /*     SF_J0 = finalOptPosj0(V0,A0,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     21-Nov-2023 12:11:12 */
    s_max_tmp = *tf * *tf;
    b_s_max_tmp = s_max_tmp * a0;
    c_s_max_tmp = *tf * v0;
    *s_max = c_s_max_tmp * 0.6 + b_s_max_tmp * 0.15;
    /* evalPrimitiveCoeffs */
    /*     COEFFICENT_V = evalPrimitiveCoeffs(V0,A0,SF,VF,AF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 23.2. */
    /*     21-Nov-2023 12:11:11 */
    t3 = 0.0 * s_max_tmp;
    t4 = b_s_max_tmp * 3.0;
    m[0] = 0.0;
    m[1] = v0;
    m[2] = a0;
    m[3] = 1.0 / rt_powd_snf(*tf, 3.0) *
           ((((*s_max * -20.0 + t4) - t3) + c_s_max_tmp * 12.0) +
            *tf * 0.0 * 8.0) *
           -3.0;
    m[4] = 1.0 / (s_max_tmp * s_max_tmp) *
           ((((*s_max * -30.0 - t3 * 2.0) + t4) + c_s_max_tmp * 16.0) +
            *tf * 0.0 * 14.0) *
           12.0;
    m[5] = 1.0 / rt_powd_snf(*tf, 5.0) *
           ((((*s_max * -12.0 - t3) + c_s_max_tmp * 6.0) + *tf * 0.0 * 6.0) +
            b_s_max_tmp) *
           -60.0;
  } else {
    *tf = 0.0;
    *s_max = 0.0;
    for (i = 0; i < 6; i++) {
      m[i] = 0.0;
    }
  }
}

void primitives_initialize(void)
{
  rt_InitInfAndNaN();
  isInitialized_primitives = true;
}

void primitives_terminate(void)
{
  isInitialized_primitives = false;
}

double v_opt_fun(double t, double v0, double a0, double sf, double vf,
                 double af, double T)
{
  double b_out1_tmp;
  double out1_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* V_OPT_FUN */
  /*     OUT1 = V_OPT_FUN(t,V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 23.2.
   */
  /*     21-Nov-2023 12:11:11 */
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return (((v0 + a0 * t) -
           1.0 / rt_powd_snf(T, 5.0) * rt_powd_snf(t, 4.0) *
               ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
                t4_tmp) *
               2.5) -
          1.0 / rt_powd_snf(T, 3.0) * (t * t) *
              ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) +
               b_out1_tmp * 8.0) *
              1.5) +
         rt_powd_snf(t, 3.0) / (t2 * t2) *
             ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
              b_out1_tmp * 14.0) *
             2.0;
}

/* End of code generation (primitives.c) */
